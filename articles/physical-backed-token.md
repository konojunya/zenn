---
title: "What is Physical Backed Token"
emoji: "ğŸ›¹"
type: "tech"
topics: ["ethereum", "nft", "pbt"]
published: true
---

[Azuki](https://azuki.com) ãŒ 2022/10/17 ã«ç™ºè¡¨ã—ãŸæ–°ã—ã„ NFT ã®è¦æ ¼ã€ŒPhysical Backed Tokenã€ã«ã¤ã„ã¦æ·±æ˜ã‚Šã—ã¦ã„ãã¾ã™ã€‚

![](https://static.looksnice.org/0x6853449a65b264478a4cD90903A65F0508441aC0/0x614d9f791a70c53370501b3753e8c882b0c38119a916db949e025c7340784c2f)

# Physical Backed Token ã¨ã¯ä½•ã‹

https://www.azuki.com/updates/pbt

Pysical Backed Token(ä»¥ä¸‹ PBT)ã¨ã¯ Azuki ãŒæ–°ã—ãä½œã£ãŸç‰©ç†çš„ãªç‰©ã¨ã‚ªãƒ³ãƒã‚§ãƒ¼ãƒ³ã®æ‰€æœ‰ã‚’åŒæœŸã•ã›ã‚‹ãŸã‚ã® EIP ã®è¦æ ¼(EIP-5791)ã§ã™ã€‚

ã“ã‚Œã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã«å¿…è¦ãªã®ã¯ PBT ã«æº–æ‹ ã—ãŸ Token ã¨ BEAN(Blockchain Enabled Authentication Network) Chip(ä»¥ä¸‹ãƒãƒƒãƒ—)ã® 2 ã¤ã®è¦ç´ ãŒé‡è¦ã«ãªã‚Šã¾ã™ã€‚ã¾ãŸãƒãƒƒãƒ—ã¯éå¯¾ç§°éµãƒšã‚¢ã‚’è‡ªå·±ç”Ÿæˆã§ãã‚‹ãƒãƒƒãƒ—ã§ã‚ã‚‹ã¨è¦ä»¶ãŒå®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚

![](https://azuki-2.ghost.io/content/images/size/w1000/2022/10/whitechipexplainer.png)

## éå¯¾ç§°éµãƒšã‚¢ã¨ã¯ï¼Ÿ

éµãƒšã‚¢ã¨ã¯ã€ãƒ–ãƒ­ãƒƒã‚¯ãƒã‚§ãƒ¼ãƒ³ã®ä¸–ç•Œã§ã‚‚ãŠé¦´æŸ“ã¿ã® **å…¬é–‹éµ** ã¨ **ç§˜å¯†éµ** ã®ä¸¡æ–¹ã‚’ä½œæˆã™ã‚‹ã“ã¨ã€ã¾ãŸãã®éµã®ã“ã¨ã‚’æŒ‡ã—ã¾ã™ã€‚éå¯¾ç§°æš—å·åŒ–ã¨ã¯ã€å…¬é–‹éµã‚’ä½¿ç”¨ã—ã¦æƒ…å ±ã‚’æš—å·åŒ–ã—å¯¾å¿œã™ã‚‹ç§˜å¯†éµã‚’ç”¨ã„ã¦æƒ…å ±ã®å¾©å·åŒ–ã‚’è¡Œã†ã“ã¨ã«ãªã‚Šã¾ã™ã€‚ã“ã®å¯¾è±¡ã¨ãªã‚‹ã®ã¯å¯¾è±¡éµæš—å·åŒ–ã§ã™ã€‚å¯¾ç…§æš—å·åŒ–ã¯ 1 ã¤ã®éµã‚’ç”¨ã„ã¦æƒ…å ±ã®æš—å·/å¾©å·ã‚’è¡Œã„ã¾ã™ã€‚

# use case

ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã¨ã—ã¦ã¯ä»¥ä¸‹ã®ã‚‚ã®ãŒã‚ã’ã‚‰ã‚Œã¦ã„ã¾ã—ãŸã€‚

- ç‰©å“ã®åˆ†æ•£å‹èªè¨¼
  - ã‚¹ãƒãƒ›ã§ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ã ã‘ã§ç¾ç‰©ã‚’èªè¨¼å¯èƒ½ã«ã™ã‚‹
- ç‰©å“ã®æ‰€æœ‰è€…ã®å±¥æ­´ã‚’è¿½è·¡å¯èƒ½ã«ã™ã‚‹
  - ãã®ç‰©å“ã®éå»ã¨ç¾åœ¨ã®æ‰€æœ‰è€…ã‚’æ¤œè¨¼å¯èƒ½ã«ã™ã‚‹ã“ã¨ã§ã€ãƒ–ãƒ©ãƒ³ãƒ‰ã¯æ‰€æœ‰è€…ã ã‘ã§ãªãå…ƒæ‰€æœ‰è€…ã‚‚å«ã‚ã¦é¡§å®¢ä½“é¨“ã‚’ä½œã‚‹ã“ã¨ãŒã§ãã‚‹
- ãƒ‡ã‚¸ã‚¿ãƒ«ä¸Šã®ä½“é¨“ã®ãŸã‚ã«ç‰©ç†çš„ãªè£½å“ã®ä½¿ç”¨ã‚’å¯èƒ½ã«ã™ã‚‹
  - ãƒ‡ã‚¸ã‚¿ãƒ«ãªãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿æœ‰ã™ã‚‹ã“ã¨ã§ç‰©ç†çš„ã«ä½•ã‹ã‚’å¾—ãŸã‚Šã€ç‰©ç†çš„ãªç‰©ã‚’ä¿æœ‰ã™ã‚‹ã“ã¨ã«ã‚ˆã‚Šãƒ‡ã‚¸ã‚¿ãƒ«ä¸Šã§ä½•ã‹ã‚’å¾—ãŸã‚Šã—ã¦ã€ç›¸äº’ã®ä¸–ç•Œã‚’å¹²æ¸‰ã•ã›ã‚‹å½¹å‰²ã‚’æŒãŸã›ã‚‹

# Azuki ã®ç›®æŒ‡ã—ãŸä¸–ç•Œ

Azuki ã¯ã“ã®ãƒãƒƒãƒ—ã‚’ä½¿ã£ã¦ç¾ç‰©ã®ã‚‚ã®ã‚’ã‚¹ã‚­ãƒ£ãƒ³ã™ã‚‹ã“ã¨ã§ãƒ‡ã‚¸ã‚¿ãƒ«ä¸Šã® PBT ã® owner ã‚‚æ‰€æœ‰è€…ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ã—ã€ç¾ç‰©ã®æ‰€æœ‰è€…ã‚’èªè¨¼ã§ãã‚‹ã‚ˆã†ã«ã—ãŸã„ã¨è€ƒãˆã¦ã„ã¾ã™ã€‚å½¼ã‚‰ã¯ã“ã®ã‚¹ã‚­ãƒ£ãƒ³ã‚’ã™ã‚‹ã“ã¨ã‚’ **scan to own** ã¨å‘¼ã‚“ã§ã„ã¾ã™ã€‚
ç›®æŒ‡ã—ãŸã„ä¸–ç•Œã¨ã—ã¦ã¯ã€ãƒ‡ã‚¸ã‚¿ãƒ«ã¨ãƒ•ã‚£ã‚¸ã‚«ãƒ«ã®ä¸–ç•Œã®å…±å‰µãªã®ã‹ãªã¨è€ƒãˆã¦ã„ã¾ã™ã€‚

![](https://storage.googleapis.com/zenn-user-upload/08be866af7e0-20221214.png)

# PBT ã®ä»•æ§˜

PBT ã¯å‰é€”ã—ãŸã‚ˆã†ã« EIP-5791 ã§è¦ç´„ãŒæ±ºã‚ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚

https://eips.ethereum.org/EIPS/eip-5791

EIP-5791 ã¨ã—ã¦å®šç¾©ã—ã¦ã„ã‚‹ã®ã¯ NFT(EIP-721)ã®æ‰€æœ‰è€…ã‚’ç‰©ç†ãƒãƒƒãƒ—ã«ãƒªãƒ³ã‚¯ã™ã‚‹ãŸã‚ã®æœ€å°é™ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ã™ã€‚ãã®ãŸã‚ EIP-5791 ã¯ EIP-721 æ‹¡å¼µã¨è¨€ãˆã¾ã™ã€‚

## ãƒ¢ãƒãƒ™ãƒ¼ã‚·ãƒ§ãƒ³

ç¾åœ¨ NFT ã‚³ãƒ¬ã‚¯ã‚¿ãƒ¼ã¯ãƒ‡ã‚¸ã‚¿ãƒ«è³‡ç”£ã‚’åé›†ã—ã€ã‚ªãƒ³ãƒ©ã‚¤ãƒ³ä¸Šã§ä»–ã®äººã¨å…±æœ‰ã—ãŸã‚Šã—ã¦ã„ã¾ã™ãŒã€ç‰©å“ã®å ´åˆãã‚ŒãŒæœ¬ç‰©ã§ã‚ã‚Šã€æ‰€æœ‰è€…ã§ã‚ã‚‹ã“ã¨ãŒç¢ºèªã•ã‚ŒãŸè³‡ç”£ã¨ã—ã¦ NFT ã‚’å±•ç¤ºã™ã‚‹éš›ã®æ˜ç¢ºãªåŸºæº–ãŒå­˜åœ¨ã—ã¦ã„ã¾ã›ã‚“ã€‚ç¾æ™‚ç‚¹ã§ã¯ NFT ã¨ç‰©ç†è³‡ç”£ã¯æ‰€æœ‰æ¨©ãŒåˆ†é›¢ã—ã¦ã‚‹ã¨è¨€ãˆã¦ã€ã“ã‚Œã‚‰ã‚’è¨¼æ˜ã™ã‚‹ã«ã¯ä¿¡é ¼ã§ãã‚‹ç¬¬ä¸‰è€…(ä¾‹ãˆã° StockX ãªã©)ã‹ã‚‰ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ãŒå¿…è¦ã«ãªã‚Šã¾ã™ã€‚

## è¦ä»¶

PBT ã§ã¯ç‰©ç†çš„ãªã‚¢ã‚¤ãƒ†ãƒ ã«å¯¾ã—ã¦ä»¥ä¸‹ã®æ¡ä»¶ã‚’æº€ãŸã™ãƒãƒƒãƒ—ã‚’è£…ç€ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

1. ãƒãƒƒãƒ—ã¯ ECDSA secp256k1 éå¯¾ç§°éµãƒšã‚¢ã‚’å®‰å…¨ã«ç”Ÿæˆã—ä¿å­˜ãŒã§ãã‚‹
2. ãƒãƒƒãƒ—ã¯ç”Ÿæˆã—ãŸç§˜å¯†éµã§ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ç½²åãŒã§ãã‚‹
3. ãƒãƒƒãƒ—ã®å…¬é–‹éµã¯å…¬é–‹ã™ã‚‹
4. ç§˜å¯†éµã‚’ãƒãƒƒãƒ—ã‹ã‚‰æŠœãå–ã‚‹ã“ã¨ã¯ã§ããªã„

## ã‚¢ãƒ—ãƒ­ãƒ¼ãƒ

NFT ã‚’ mint ã™ã‚‹éš›ã«å¯¾å¿œã™ã‚‹ãƒãƒƒãƒ—ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å«ã‚“ã ã‚¤ãƒ™ãƒ³ãƒˆã‚’æŠ•ã’ã‚‹å¿…è¦ãŒã‚ã‚Šã€NFT ã¯ãƒãƒƒãƒ—ã¨ãƒªãƒ³ã‚¯ã—ã¦ãªã„ã¨ mint ã§ããªã„ã‚ˆã†ã«ã—ã¾ã™ã€‚
`transferTokenWithChip` ã¨ã„ã†é–¢æ•°ã‚’å‘¼ã¶ã“ã¨ã§ã€ãƒãƒƒãƒ—ã«ã‚ˆã‚Šç½²åã•ã‚ŒãŸæœ‰åŠ¹ãªç½²åãŒæ¸¡ã•ã‚ŒãŸå ´åˆã« msg.sender ã«å¯¾ã—ã¦ NFT ã‚’ transfer ã—ã¾ã™ã€‚

## æ³¨æ„äº‹é …

ä»¥ä¸‹ã®ã“ã¨ã¯ã“ã® EIP ã®ç¯„å›²å¤–ã«ãªã‚Šã¾ã™ã€‚

- ç‰¹å®šã® NFT ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ãƒãƒƒãƒ—ã‚¢ãƒ‰ãƒ¬ã‚¹ãŒä»»æ„ã® EOA ã§ãªãã€ã‚¢ã‚¤ãƒ†ãƒ ã«åŸ‹ã‚ã‚‰ã‚ŒãŸç‰©çŸ¥çš„ãªãƒãƒƒãƒ—ãŒå®Ÿéš›ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã•ã‚Œã¦ã„ã‚‹ã“ã¨ã‚’ä¿¡é ¼ã™ã‚‹ã“ã¨
- ãƒãƒƒãƒ—ã®åŠ£åŒ–ã‚„æå‚·ãŒãªã„ã“ã¨ã‚’ä¿è¨¼ã™ã‚‹ã“ã¨
- ãƒãƒƒãƒ—ãŒç‰©ç†çš„ãªã‚‚ã®ã«å–ã‚Šä»˜ã‘ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨
- tokenId ã‚’ãƒãƒƒãƒ—ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã«ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã“ã¨

  - ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’ã™ã‚‹ã“ã¨ã¯å¿…è¦ã ãŒã€ã©ã®ã‚ˆã†ã«ã—ã¦ãƒãƒƒãƒ”ãƒ³ã‚°ã™ã‚‹ã‹ã¯ EIP ã®å¯¾è±¡å¤–

# å®Ÿè£…

https://github.com/chiru-labs/PBT

ç¾çŠ¶ã® EIP-5791 ã¯ä»¥ä¸‹ã® interface ã‚’å®Ÿè£…ã™ã‚‹ã“ã¨ã‚’è¦ç´„ã¨ã—ã¦æ±ºã‚ã¦ã„ã¾ã™ï¼ˆ2022/12/04 ç¾åœ¨ï¼‰

```solidity
interface IERC5791 {
  function tokenIdFor(address chipAddress) external view returns (uint256);
  function isChipSignatureForToken(uint256 tokenId, bytes calldata payload, bytes calldata signature) external view returns (bool);
  function transferTokenWithChip(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig, bool useSafeTransferFrom) external;
  function transferTokenWithChip(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig) external;

  event PBTMint(uint256 indexed tokenId, address indexed chipAddress);
  event PBTChipRemapping(uint256 indexed tokenId, address indexed oldChipAddress, address indexed newChipAddress);
}
```

## ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã‚’èª­ã‚“ã§ã¿ã‚‹

ã¾ãšç¶™æ‰¿ã—ã¦ã‚‹ã®ã¯ ERC-721 ã§ã¯ãªã `ERC721ReadOnly` ã«ãªã‚Šã¾ã™ã€‚

```solidity
contract ERC721ReadOnly is ERC721 {
  constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}

  function approve(address to, uint256 tokenId) public virtual override {
      revert("ERC721 public approve not allowed");
  }

  function getApproved(uint256 tokenId) public view virtual override returns (address) {
      require(_exists(tokenId), "ERC721: invalid token ID");
      return address(0);
  }

  function setApprovalForAll(address operator, bool approved) public virtual override {
      revert("ERC721 public setApprovalForAll not allowed");
  }

  function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
      return false;
  }

  function transferFrom(address from, address to, uint256 tokenId) public virtual override {
      revert("ERC721 public transferFrom not allowed");
  }

  function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
      revert("ERC721 public safeTransferFrom not allowed");
  }

  function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
      revert("ERC721 public safeTransferFrom not allowed");
  }
}
```

approve / getApproved / setApprovalForAll / isApprovalForAll / transferFrom / safeTransferFrom ãŒå…¨ã¦ revert ã§ override ã•ã‚Œã¦ã„ã¾ã™ã€‚PBT ã¯ scan ã§ã—ã‹ NFT ã‚’ç§»å‹•ã§ããªã„ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã®åˆ¶ç´„ã«ãªã‚Šã¾ã™ã€‚

PBT TokenData ã®å½¢ã¯ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¦ã„ã¾ã™ã€‚ERC-721 ã® tokenId ã¨ chipAddress ãŒã‚»ãƒƒãƒˆã«ãªã£ã¦ã„ã¾ã™ã€‚

```solidity
struct TokenData {
    uint256 tokenId;
    address chipAddress;
    bool set;
}
```

chipAddress ã¨ tokenId ã®ãƒãƒƒãƒ”ãƒ³ã‚°ã‚’æœ€åˆã«ä½œæˆã—ã¾ã™ã€‚tokenId ã® owner ãŒ Null Address ã˜ã‚ƒãªã„æ™‚ã« revert ã•ã‚Œã‚‹åˆ†å²ãŒå…¥ã£ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯ãã‚‚ãã‚‚æ—¢å­˜ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®å ´åˆã€Proxy ãƒ‘ã‚¿ãƒ¼ãƒ³ãªã©ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã‚’å†ãƒ‡ãƒ—ãƒ­ã‚¤ã§ãã‚‹å½¢ã«ãªã£ã¦ã„ãªã„ã¨ ERC-721 ã‚’ ERC-5791 ã«å¾Œã‹ã‚‰ã§ããªã„ã®ã§ã€åŸºæœ¬çš„ã«ä»Šã‹ã‚‰å§‹ã‚ã‚‹ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ä½¿ã†å‰æã®ã‚ˆã†ãªã‚³ãƒ¼ãƒ‰ã«ãªã£ã¦ã„ã¾ã™ã€‚ã¾ãŸ PBT ã«ã§ããŸã¨ã—ã¦ã‚‚ç¾ç‰©ã®ã‚‚ã®ã‚’ holder ã«é€ã‚‰ãªã„ã¨ã„ã‘ãªããªã‚Šã€NFT èµ·ç‚¹ã§ã‚‚ã®ãŒå‹•ã„ã¦ã„ã‚‹ã®ã§æ€æƒ³ã¨ãƒãƒƒãƒã—ãªã„ãªã¨ç­†è€…ã‚‚è€ƒãˆã¾ã™ã€‚

```solidity
function _seedChipToTokenMapping(address[] memory chipAddresses, uint256[] memory tokenIds, bool throwIfTokenAlreadyMinted) internal {
  uint256 tokenIdsLength = tokenIds.length;

  if (tokenIdsLength != chipAddresses.length) {
    revert ArrayLengthMismatch();
  }

  for (uint256 i = 0; i < tokenIdsLength; ++i) {
    address chipAddress = chipAddresses[i];
    uint256 tokenId = tokenIds[i];

    if (throwIfTokenAlreadyMinted && _exists(tokenId)) {
      revert SeedingChipDataForExistingToken();
    }

    _tokenDatas[chipAddress] = TokenData(tokenId, chipAddress, true);
  }
}
```

chipAddress ã‹ã‚‰ tokenId ã‚’æŠœã„ã¦ãã‚‹å®Ÿè£…ã€‚

```solidity
function tokenIdMappedFor(address chipAddress) public view returns (uint256) {
  if (!_tokenDatas[chipAddress].set) {
    revert NoMappedTokenForChip();
  }

  return _tokenDatas[chipAddress].tokenId;
}

function tokenIdFor(address chipAddress) external view override returns (uint256) {
  uint256 tokenId = tokenIdMappedFor(chipAddress);

  if (!_exists(tokenId)) {
    revert NoMintedTokenForChip();
  }

  return tokenId;
}
```

token ã® transfer ã‚’è¡Œã†å®Ÿè£…ã§ã™ã€‚ã©ã® token ã® transfer ã‚’ã™ã‚‹ã‹ã‚’ç›´æ¥å¼•æ•°ã«å–ã‚‰ãšã€wallet address ã¨ block number ã‚’ç¹‹ã„ã ã‚‚ã®ã®ç½²åã€ãã®æ™‚ã«ä½¿ã£ãŸ block number ã‚’å¼•æ•°ã«æ¸¡ã—ã¦ã€ãã“ã‹ã‚‰ recover ã‚’è¡Œã„ãƒãƒƒãƒ—ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å°ãã¾ã™ã€‚ãã®å¾Œã€ãƒãƒƒãƒ—ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ tokenId ã‚’å¼•ã„ã¦ãã‚‹ã“ã¨ã§ NFT ã® transfer ã‚’è¡Œãªã£ã¦ã„ã¾ã™ã€‚
block number ã¯æœ€æ–°ã®ã‚‚ã®ã‚’ã„ã‚Œã¦ç½²åã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ã©ã®ç¨‹åº¦èª¤å·®ã‚’è¨±ã™ã‹ã‚’ `getMaxBlockhashValidWindow()` ã¨ã„ã†é–¢æ•°ã§æ±ºã‚ã¦ã„ã¾ã™ã€‚ã‚µãƒ³ãƒ—ãƒ«ã§ã¯ 100 block ã¾ã§ã¯è¨±ã—ã¦ãã‚Œã‚‹ã‚ˆã†ã«è¨­å®šã•ã‚Œã¦ã„ã¾ã™ã€‚

```solidity
function _transferTokenWithChip(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig, bool useSafeTransferFrom) internal virtual {
  uint256 tokenId = _getTokenDataForChipSignature(signatureFromChip, blockNumberUsedInSig).tokenId;

  if (useSafeTransferFrom) {
    _safeTransfer(ownerOf(tokenId), _msgSender(), tokenId, "");
  } else {
    _transfer(ownerOf(tokenId), _msgSender(), tokenId);
  }
}

function _getTokenDataForChipSignature(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig) internal view returns (TokenData memory) {
  // The blockNumberUsedInSig must be in a previous block because the blockhash of the current
  // block does not exist yet.
  if (block.number <= blockNumberUsedInSig) {
    revert InvalidBlockNumber();
  }

  unchecked {
    if (block.number - blockNumberUsedInSig > getMaxBlockhashValidWindow()) {
      revert BlockNumberTooOld();
    }
  }

  bytes32 blockHash = blockhash(blockNumberUsedInSig);
  bytes32 signedHash = keccak256(abi.encodePacked(_msgSender(), blockHash)).toEthSignedMessageHash();
  address chipAddr = signedHash.recover(signatureFromChip);

  TokenData memory tokenData = _tokenDatas[chipAddr];
  if (tokenData.set) {
    return tokenData;
  }

  revert InvalidSignature();
}
```

ã¤ã¾ã‚Š scan ã—ãŸæ™‚ã«æœ€æ–°ã® block number ã¨ scan ã—ãŸ wallet ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’ãƒãƒƒãƒ—ã®ç§˜å¯†éµã‚’ä½¿ã£ã¦ç½²åã—ãã“ã§å¾—ãŸ signature ã¨ block number ã‚’ç”¨ã„ã¦ã©ã® NFT ã‚’ç§»å‹•ã•ã›ã‚‹ã®ã‹æ±ºã‚ã¦ transfer ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚

ERC-721 ã® \_transfer ã¯ openzeppelin ã®å®Ÿè£…ã‚’è¦‹ã‚‹é™ã‚Šæœ€åˆã«ã„ã‹ã®ã‚ˆã†ã« tokenId ã® owner ãŒ from ã® address ã¨åŒã˜ã‹ã©ã†ã‹ã‚’ç¢ºèªã—ã¦ã„ã¾ã™ã€‚ã“ã®ã‚µãƒ³ãƒ—ãƒ«å®Ÿè£…ã§ã¯ from ã«å¯¾ã—ã¦ `ownerOf(tokenId)` ã‚’ã„ã‚Œã¦ã„ã‚‹ã®ã§ã€ã“ã® require ã«ã¯ 100%å¼•ã£ã‹ã‹ã‚Šã¾ã›ã‚“ã€‚ã“ã®ã“ã¨ã‹ã‚‰ scan ã‚’ã§ãã‚Œã° owner ã®æ„æ€ã«é–¢ä¿‚ãªãã€NFT ã‚’ç›—ã‚€ã“ã¨ãŒã§ãã¾ã™ã€‚ã—ã‹ã— transferFrom ãŒç¦æ­¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€ãã® NFT ã‚’ã¾ãŸåˆ¥ã® wallet ã«ã†ã¤ã—ãŸã‚Šã€ãƒãƒ¼ã‚±ãƒƒãƒˆãƒ—ãƒ¬ã‚¤ã‚¹ã«å‡ºå“ã—ãŸã‚Šã§ããªã„ã—ã€ã‚‚ã†ä¸€åº¦ç¾ç‰©ã®æ‰€æœ‰è€…ãŒ scan ã‚’è¡Œãˆã° NFT ã¯æ‰€æœ‰è€…ã®å…ƒã«å¸°ã£ã¦ãã¾ã™ã€‚ã“ã‚Œã‚‰ã®ã“ã¨ã‹ã‚‰ãŸã  gas ä»£ã‚’æ‰•ã†ã ã‘ã«ãªã£ã¦ã—ã¾ã†ã®ã§ã€NFT ã ã‘ç›—ã‚“ã§ã‚‚æ„å‘³ãŒãªã„ã‚ˆã†ãªè¨­è¨ˆã«ãªã£ã¦ã„ã‚‹ã¨ã„ã†è¦‹æ–¹ãŒã§ãã¾ã™ã€‚
PBT ã§ã¯ã‚‚ã®ãŒä¸­å¿ƒã®ä¸–ç•ŒãªãŸã‚ã€ã‚‚ã®ã‚’é…é€ã—ã¦æ–°ã—ã„æ‰€æœ‰è€…ã«ãªã£ãŸæ™‚ã€ãã®æ‰€æœ‰è€…ãŒå…ƒã®æ‰€æœ‰è€…ã®æ„æ€ã«é–¢ä¿‚ãªã scan ã‚’ã™ã‚‹ã“ã¨ã§ NFT ã‚’æ‰‹å…ƒã¸æŒã£ã¦ã“ã‚Œã‚‹ã‚ˆã†ã«ã™ã‚‹ãŸã‚ã€ã“ã®ã‚ˆã†ãªå®Ÿè£…ã«ãªã£ã¦ã„ã‚‹ã®ã‹ãªã¨æ¨å¯Ÿã—ã¾ã™ã€‚

```solidity
require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¼ã¸ã®é…æ…®

`transferTokenWithChip` ã«æ¸¡ã•ã‚Œã‚‹ç½²åã¯ EIP-191 ç½²åã«ãªã£ã¦ãŠã‚Šã€ç½²åãƒ‡ãƒ¼ã‚¿å†…ã«é–¢æ•°ã®å‘¼ã³å‡ºã—å…ƒã®ã‚¢ãƒ‰ãƒ¬ã‚¹(msg.sender)ãŒå¿…è¦ã«ãªã‚‹ãŸã‚ã€ãƒªãƒ—ãƒ¬ã‚¤æ”»æ’ƒã§ç½²åãŒæ‚ªç”¨ã•ã‚Œã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
ã¾ãŸæ‚ªæ„ã®ã‚ã‚‹ãƒãƒƒãƒ—ã®æ‰€æœ‰è€…ãŒçŸ­æœŸé–“å¾Œã«ä½¿ç”¨ã™ã‚‹ç½²åã‚’äº‹å‰ã«ç”Ÿæˆã§ããªã„ã‚ˆã†ã«ç›´è¿‘ã®ãƒ–ãƒ­ãƒƒã‚¯ãƒãƒƒã‚·ãƒ¥ã‚’å¿…è¦ã¨ã—ã¦ã„ã¾ã™ã€‚

# Azuki ã® GoldenSkateboard ã® å®Ÿè£…ã‚’èª­ã‚€

![](https://azk.imgix.net/shao2.jpg)

Azuki ã¯ GoldenSkateboard ä»¥å¤–ã«ã‚‚ãƒ‘ãƒ¼ã‚«ãƒ¼ãªã© PBT ã‚’ã™ã§ã«è²©å£²ã—ã¦ã„ã¾ã™ãŒã€ä»Šå›ã¯ã‚¹ã‚±ãƒœãƒ¼ã® PBT ã®å®Ÿè£…ã‚’èª­ã‚“ã§ã¿ã¾ã™ã€‚
etherscan ã§ç¢ºèªã§ãã¾ã™ãŒ GoldenSkateboard ã® EIP-5791 å®Ÿè£…ã¯ä»¥ä¸‹ã®å®Ÿè£…ã«ãªã‚Šã¾ã™ã€‚

https://etherscan.io/address/0x6853449a65b264478a4cd90903a65f0508441ac0#code

åŸºæœ¬çš„ã«ã¯ä¸Šè¨˜ã§è¦‹ã¦ããŸ PBTSimple.sol ã‚’ç¶™æ‰¿ã—ã¦ã‚‹ã ã‘ã®ã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆãªã®ã§ã‚·ãƒ³ãƒ—ãƒ«ã§ã™ã€‚mint ã®å®Ÿè£…ã ã‘è¡Œã£ã¦ã„ãŸã®ã§ãã“ã ã‘èª­ã‚“ã§ã„ãã¾ã™ã€‚

```solidity
function mintSkateboard(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig) external {
  if (!canMint) {
    revert MintNotOpen();
  }

  if (supply == TOTAL_SUPPLY) {
    revert TotalSupplyReached();
  }

  _mintTokenWithChip(signatureFromChip, blockNumberUsedInSig);

  unchecked {
    ++supply;
  }
}
```

`_mintTokenWithChip` ã‚’èª­ã‚“ã§ã„ã‚‹ã ã‘ã§ã€ã‚ã¨ã¯ç·é‡ã®ç®¡ç†ã¯ã“ã®ç¶™æ‰¿ã—ãŸã‚³ãƒ³ãƒˆãƒ©ã‚¯ãƒˆã§è¡Œã£ã¦ã„ã‚‹ãŸã‚ãã®å®Ÿè£…ã ã‘å­˜åœ¨ã—ã¾ã™ã€‚

```solidity
function _mintTokenWithChip(bytes calldata signatureFromChip, uint256 blockNumberUsedInSig) internal returns (uint256) {
  TokenData memory tokenData = _getTokenDataForChipSignature(signatureFromChip, blockNumberUsedInSig);
  uint256 tokenId = tokenData.tokenId;
  _mint(_msgSender(), tokenId);
  emit PBTMint(tokenId, tokenData.chipAddress);
  return tokenId;
}
```

å˜ç´”ã« ERC-721 ã® `_mint` ã‚’å®Ÿè¡Œã—ã¦ã‚‹ã ã‘ã§ã™ã€‚ PBTMint event ã® emit ã ã‘ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ãŒã€ãƒãƒƒãƒ—ã‚’ã©ã†ã‚„ã£ã¦ç”¨æ„ã™ã‚‹ã‚“ã ã‚ˆï¼ã£ã¦å•é¡Œã ã‘è§£æ±ºã§ãã‚Œã° PBT ã®å®Ÿè£…è‡ªä½“ã¯ãã‚“ãªã«é›£ã—ããªã•ãã†ã§ã™ã­ã€‚
